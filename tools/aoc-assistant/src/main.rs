use aoc_assistant::add_day::Error;
use aoc_assistant::{add_day, get_statement};
use clap::{Arg, ArgAction, ArgGroup, Command, value_parser};

fn extract_session_key(
    session_key_arg: Option<&String>,
    session_file_arg: Option<&String>,
) -> String {
    match (session_key_arg, session_file_arg) {
        (Some(session_key), None) => session_key.clone(),
        (None, Some(session_file)) => {
            std::fs::read_to_string(session_file).expect("Failed to read session key from file")
        }
        _ => unreachable!("Session key or session file must be provided"),
    }
}

trait CommandExt {
    fn with_year_and_day_args(self) -> Self;
    fn with_session_args(self) -> Self;
}

impl CommandExt for Command {
    fn with_year_and_day_args(self) -> Self {
        self.arg(
            Arg::new("year")
                .short('y')
                .long("year")
                .value_name("YEAR")
                .value_parser(value_parser!(u32).range(2015..=2099))
                .required(true)
                .help("Selects the year (format XXXX, as for instance, 2023) of the puzzle"),
        )
        .arg(
            Arg::new("day")
                .short('d')
                .long("day")
                .value_name("DAY")
                .value_parser(value_parser!(u32).range(1..=25))
                .required(true)
                .help("Selects the day (from 1 to 25) of the puzzle"),
        )
    }

    fn with_session_args(self) -> Self {
        self.arg(
            Arg::new("session")
                .short('s')
                .long("session")
                .value_name("SESSION_KEY")
                .help("Provides the session key string of the cookie generated by logging in into the Advent of Code official webpage"),
        )
            .arg(
                Arg::new("session-file")
                    .short('S')
                    .long("session-file")
                    .value_name("FILE")
                    .help("Select the file where the script can find the session key string of the cookie generated by logging in into the Advent of Code official webpage"),
            )
            .group(
                ArgGroup::new("session_group")
                    .args(["session", "session-file"])
                    .required(true),
            )
    }
}

fn main() {
    let cli = Command::new("aoc-assistant")
        .about("Assistant for managing this project to solve Advent of Code puzzles")
        .disable_help_subcommand(true)
        .arg_required_else_help(true)
        .subcommand_required(true)
        .subcommand(
            Command::new("add_day")
                .about("Set up the project to add a new \"Advent Of Code\" puzzle")
                .with_year_and_day_args()
                .arg(
                    Arg::new("force")
                        .short('f')
                        .long("force")
                        .action(ArgAction::SetTrue)
                        .help("Forces the overwrite of existing files"),
                ).with_session_args(),
        )
        .subcommand(
            Command::new("get_statement")
                .about("Downloads the statement (both parts if available) for the \"Advent Of Code\" selected puzzle")
                .with_year_and_day_args()
                .with_session_args()
        );
    let cli_matches = cli.get_matches();

    match cli_matches.subcommand() {
        Some(("add_day", sub_matches)) => {
            let year: u32 = *sub_matches.get_one("year").unwrap();
            let day: u32 = *sub_matches.get_one("day").unwrap();
            let force: bool = sub_matches.get_flag("force");
            let session_key = extract_session_key(
                sub_matches.get_one("session"),
                sub_matches.get_one("session-file"),
            );
            let result =
                add_day(year, day, &session_key, force) || get_statement(year, day, &session_key);
            if !result {
                std::process::exit(1);
            }
        }
        Some(("get_statement", sub_matches)) => {
            let year: u32 = *sub_matches.get_one("year").unwrap();
            let day: u32 = *sub_matches.get_one("day").unwrap();
            let session_key = extract_session_key(
                sub_matches.get_one("session"),
                sub_matches.get_one("session-file"),
            );
            let result = get_statement(year, day, &session_key);
            if !result {
                std::process::exit(1);
            }
        }
        _ => unreachable!("Exhausted list of subcommands and subcommand_required prevents `None`"),
    }
}

fn add_day(year: u32, day: u32, session_key: &str, force: bool) -> bool {
    if let Err(e) = add_day::add_new_day(add_day::AddDayParameters {
        year,
        day,
        session_key: session_key.to_string(),
        force,
    }) {
        match e {
            Error::NetworkError => {
                eprintln!("Network error: Unable to connect to the server.")
            }
            Error::ParseError => {
                eprintln!("Parse error: Unable to parse the response from the server.")
            }
            Error::FolderAlreadyExists => {
                eprintln!("Error: The puzzle folder already exists. Use --force to overwrite.")
            }
            Error::IoError => eprintln!("I/O error: Unable to read or write files."),
            Error::MissingTemplate => {
                eprintln!("Error: Missing template files for the new puzzle.")
            }
            Error::InvalidSessionKey => eprintln!("Error: Invalid session key provided."),
            Error::GetStatementError => {
                eprintln!("Error: Failed while generating puzzle description.")
            }
        }
        return false;
    };
    true
}

fn get_statement(year: u32, day: u32, session_key: &str) -> bool {
    if let Err(e) = get_statement::get_puzzle_statement(get_statement::GetStatementParameters {
        year,
        day,
        session_key: session_key.to_string(),
    }) {
        match e {
            get_statement::Error::NetworkError => {
                eprintln!("Network error: Unable to connect to the server.")
            }
            get_statement::Error::ParseError => {
                eprintln!("Parse error: Unable to parse the response from the server.")
            }
            get_statement::Error::FolderNotFound => {
                eprintln!("Error: The puzzle folder does not exist. Please add the day first.")
            }
            get_statement::Error::IoError => {
                eprintln!("I/O error: Unable to read or write files.")
            }
            get_statement::Error::MissingTemplate => {
                eprintln!("Error: Missing template files for the new puzzle.")
            }
        }
        return false;
    };
    true
}
